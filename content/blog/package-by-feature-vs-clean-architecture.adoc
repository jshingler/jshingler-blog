+++
title = "Package by Layer vs Package by Feature (How Clean Architecture and Hexigonal Architecture fit in)"
date = 2025-10-25
author = "Jim Shingler"
description = "A practical guide to structuring your Spring Boot applications â€” exploring package-by-layer, package-by-feature, and how Clean Architecture and Hexagonal Architecture fit together."
tags =["Spring Boot", "Architecture", "Clean Architecture", "Hexagonal Architecture", "Software Design", "java"]
banner = "img/banners/packageLayerFunction.png"
+++

== Package by Layer vs Package by Feature

=== How Clean Architecture and Hexagonal Architecture fit in

In Java Spring Boot development, one of the most impactful architectural
choices youâ€™ll make is how to *organize your code*. +
Should you package by _layer_ â€” like controller, service, and repository
â€” or by _feature_ â€” like order, customer, and inventory?

And where do *Clean Architecture* and *Hexagonal Architecture* fit into
all of this?

Letâ€™s unpack the trade-offs, principles, and evolution path â€” with a
touch of wisdom inspired by https://danvega.dev[Dan Vega], whoâ€™s known
for his pragmatic approach to clean, maintainable Spring Boot
applications.

'''''

=== ğŸ§± Package by Layer â€” The Traditional Approach

==== Example Structure

[source,text]
----
com.example.orders
â”œâ”€â”€ controller
â”‚   â””â”€â”€ OrderController.java
â”œâ”€â”€ service
â”‚   â””â”€â”€ OrderService.java
â”œâ”€â”€ repository
â”‚   â””â”€â”€ OrderRepository.java
â””â”€â”€ model
    â””â”€â”€ Order.java
----

==== Philosophy

Group classes by their _technical role_ â€” all controllers together, all
services together, all repositories together.

==== Pros

* Clear separation of concerns +
* Familiar and easy for newcomers +
* Works fine for small or simple apps

==== Cons

* *Low cohesion:* Each featureâ€™s code is scattered +
* *Tight coupling:* Shared services and models blur boundaries +
* *Poor scalability:* Harder to isolate or modularize features

==== When to Use

Package-by-layer works well when: - Youâ€™re building a *small app or
prototype* +
- The *team is small and co-located* +
- You donâ€™t anticipate splitting into modules or services later

'''''

=== ğŸ§© Package by Feature â€” The Modern Approach

==== Example Structure

[source,text]
----
com.example.orders
â”œâ”€â”€ order
â”‚   â”œâ”€â”€ OrderController.java
â”‚   â”œâ”€â”€ OrderService.java
â”‚   â”œâ”€â”€ OrderRepository.java
â”‚   â””â”€â”€ Order.java
â”œâ”€â”€ customer
â”‚   â”œâ”€â”€ CustomerController.java
â”‚   â”œâ”€â”€ CustomerService.java
â”‚   â”œâ”€â”€ CustomerRepository.java
â”‚   â””â”€â”€ Customer.java
----

==== Philosophy

Group code by *business capability* or *domain concept*, not by
technical role.

==== Pros

* High cohesion â€” each feature is self-contained +
* Easier to reason about, test, and refactor +
* Natural fit for *domain-driven design (DDD)* +
* Enables modular ownership and microservice extraction

==== Cons

* Less conventional â€” can confuse new developers +
* Requires discipline to avoid cross-feature coupling +
* May duplicate small utilities across features (by design)

==== When to Use

Use package-by-feature when: - Youâ€™re building a *larger or growing
system* +
- You expect *multiple teams or domains* +
- You want to evolve toward *modularity or microservices*

'''''

=== âš–ï¸ Package-by-Layer vs Package-by-Feature

[cols=",,",options="header",]
|===
|Aspect |Package by Layer |Package by Feature
|*Cohesion* |Low |High
|*Coupling* |High |Low
|*Refactorability* |Harder |Easier
|*Testing* |Broad integration tests |Isolated feature tests
|*Scalability* |Monolithic |Modular
|*Team Fit* |Centralized ownership |Cross-functional ownership
|===

'''''

=== ğŸ§­ Enter Clean Architecture

*Creator:* Robert C. Martin (Uncle Bob)

*Core Rule:* +
> Business logic should not depend on frameworks, databases, or UI.
Dependencies point *inward*, toward the domain.

==== Conceptual View

[source,text]
----
Frameworks & UI (Spring, REST)
        â†“
Interface Adapters (DTOs, Mappers)
        â†“
Application Services (Use Cases)
        â†“
Domain Entities (Business Rules)
----

==== Example Layout

[source,text]
----
com.example.order
â”œâ”€â”€ domain
â”‚   â””â”€â”€ Order.java
â”œâ”€â”€ application
â”‚   â””â”€â”€ PlaceOrderUseCase.java
â”œâ”€â”€ interfaces
â”‚   â””â”€â”€ web
â”‚       â””â”€â”€ OrderController.java
â””â”€â”€ infrastructure
    â””â”€â”€ JpaOrderRepository.java
----

==== Key Idea

Your *domain* and *application* code should know _nothing_ about Spring,
HTTP, or JPA. +
Theyâ€™re just Java. The outer layers handle frameworks and adapters.

'''''

=== ğŸ”¶ Hexagonal Architecture (Ports & Adapters)

*Creator:* Alistair Cockburn

*Goal:* +
> Make your application independent of its runtime environment.

==== Conceptual Diagram

[source,text]
----
           +------------------------+
           |        Adapters        |
           | (REST, DB, Kafka, etc) |
           +------------------------+
             â†‘                â†“
         Inbound Port     Outbound Port
             â†‘                â†“
           +----------------------+
           |      Domain Core     |
           |  Entities & UseCases |
           +----------------------+
----

==== Example Structure

[source,text]
----
com.example.order
â”œâ”€â”€ application
â”‚   â”œâ”€â”€ port
â”‚   â”‚   â”œâ”€â”€ inbound
â”‚   â”‚   â”‚   â””â”€â”€ PlaceOrderUseCase.java
â”‚   â”‚   â””â”€â”€ outbound
â”‚   â”‚       â””â”€â”€ OrderRepository.java
â”‚   â””â”€â”€ service
â”‚       â””â”€â”€ PlaceOrderService.java
â”œâ”€â”€ domain
â”‚   â””â”€â”€ Order.java
â”œâ”€â”€ adapters
â”‚   â”œâ”€â”€ inbound
â”‚   â”‚   â””â”€â”€ OrderController.java
â”‚   â””â”€â”€ outbound
â”‚       â””â”€â”€ JpaOrderRepository.java
----

==== Focus

Clean architecture focuses on _dependency direction_. +
Hexagonal focuses on _communication boundaries (ports and adapters)._ +
In practice, most modern teams blend both.

'''''

=== ğŸ§© The Hybrid: Package-by-Feature + Clean/Hexagonal Inside

Hereâ€™s the _best of both worlds_:

[source,text]
----
com.example.shop
â”œâ”€â”€ order
â”‚   â”œâ”€â”€ domain
â”‚   â”œâ”€â”€ application
â”‚   â”œâ”€â”€ adapters
â”‚   â”‚   â”œâ”€â”€ inbound
â”‚   â”‚   â””â”€â”€ outbound
â”‚   â””â”€â”€ infrastructure
â”œâ”€â”€ customer
â”‚   â”œâ”€â”€ domain
â”‚   â”œâ”€â”€ application
â”‚   â”œâ”€â”€ adapters
â”‚   â””â”€â”€ infrastructure
â””â”€â”€ shared
    â”œâ”€â”€ config
    â””â”€â”€ common
----

Each *feature*: - Owns its own domain, application, and adapters +
- Respects Clean/Hexagonal layering internally +
- Can evolve independently or be extracted later

'''''

=== ğŸ§  Why It Works

[cols=",",options="header",]
|===
|Principle |Benefit
|Feature-first |Keeps code cohesive and understandable
|Layering within feature |Enforces clean boundaries
|Isolation |Easier testing and refactoring
|Scalability |Each feature can evolve separately
|Spring alignment |Works naturally with component scanning
|===

This hybrid structure is exactly what many experienced Spring Boot
engineers (Dan Vega included) use for production systems.

'''''

=== ğŸ§© Take on All This

It boils down to *practicality over purity*. +
Remember do not to overcomplicate your first commit.

==== 1. Start Simple

____
``You donâ€™t earn the right to a Clean Architecture until you have
complexity to clean.''
____

Begin with package-by-feature. Refactor toward layers _as needed_.

==== 2. Use Spring Idiomatically

Donâ€™t fight the framework â€” let Spring handle DI and config. Keep your
domain pure, but use `@Service`, `@Repository`, and `@RestController`
where appropriate.

==== 3. Organize for Humans

____
``Your package structure should tell the story of your app â€” what it
does, not just what tech it uses.''
____

==== 4. Think in Use Cases

Replace CRUD-style services with explicit, business-driven use cases.

[source,java]
----
interface PlaceOrderUseCase {
    OrderResponse placeOrder(OrderRequest request);
}
----

==== 5. Design for Testability

____
``If itâ€™s hard to test, itâ€™s in the wrong place.''
____

Keep domain logic testable without Spring. +
Controllers and repos should have their own slice tests.

==== 6. Optimize Developer Experience

____
``If your app takes longer to boot than it takes to pour a coffee, fix
your architecture.''
____

Use fast feedback loops, Spring DevTools, and modular scanning.

==== 7. Refactor Toward Clean

____
``Good architecture is what lets you keep shipping features without
hating yourself in six months.''
____

'''''

=== ğŸ§© The Evolution Path

[width="100%",cols="27%,37%,18%,18%",options="header",]
|===
|Stage |Structure |Pros |Cons
|*1. Package-by-layer* |`controller/service/repository` |Simple
|Scattered logic

|*2. Package-by-feature (flat)* |`order/OrderService.java` |Feature
cohesion |Weak boundaries

|*3. Package-by-feature + internal layers* |`order/domain/...` |Cohesion
+ discipline |Slightly more setup
|===

Thatâ€™s the natural journey â€” and itâ€™s exactly what Dan Vega (and most
senior Spring engineers) would recommend.

'''''

=== ğŸ’¡ Key Takeaways

* *Package by feature* for cohesion. +
* *Layer within each feature* for clean boundaries. +
* *Evolve gradually* â€” architecture maturity comes with complexity. +
* *Use Spring idiomatically* â€” it already supports this style. +
* *Design for humans and testability* â€” thatâ€™s the real ``clean.''

'''''

____
``Group by business capability, structure by architectural boundary.'' +
â€” A principle for every scalable Spring Boot codebase.
____

'''''


== Additional Resources

=== The Book (Primary Source)

*Clean Architecture: A Craftsmanâ€™s Guide to Software Structure and Design* by Robert C. Martin (Uncle Bob)
Oâ€™Reilly Media Â· Google Books

This is the definitive reference â€” covering architecture goals, design principles, component boundaries, and proven patterns for maintainable systems.

- Oâ€™Reilly Media:: https://www.oreilly.com/library/view/clean-architecture-a/9780134494272/
- Google Books:: https://books.google.com/books/about/Clean_Architecture.html?id=ikQZswEACAAJ

---

=== Blog Post by Uncle Bob

*â€œThe Clean Architectureâ€* â€” by Robert C. Martin
Published on the *Clean Coder Blog*

Good for hearing the ideas in his own voice â€” frameworks, rules, and why the dependency direction matters.

- Clean Coder Blog:: https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html

---

=== Original Article by the Creator (Hexagonal Architecture)

*Hexagonal Architecture* â€” by Alistair Cockburn

Alistair Cockburnâ€™s write-up is a must-read â€” it provides the foundational thinking behind the Ports and Adapters pattern and is ideal for grounding your understanding.

- alistair.cockburn.us:: https://alistair.cockburn.us/hexagonal-architecture/
- alistaircockburn.com:: https://alistaircockburn.com/hexagonal-architecture/

---

=== AWS Prescriptive Guidance

*Hexagonal Architecture â€“ AWS Prescriptive Guidance*

The Amazon Web Services documentation offers a practical overview of Hexagonal Architecture and when to apply it.

Useful for seeing how the pattern is applied in scalable, cloud-native contexts.

- AWS Documentation:: https://docs.aws.amazon.com/prescriptive-guidance/latest/cloud-design-patterns/hexagonal-architecture.html
